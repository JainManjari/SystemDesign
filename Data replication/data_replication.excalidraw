{
  "type": "excalidraw",
  "version": 2,
  "source": "https://excalidraw.com",
  "elements": [
    {
      "type": "text",
      "version": 6933,
      "versionNonce": 1072967863,
      "index": "c09u",
      "isDeleted": false,
      "id": "RiKyZV-EOmbIeFjXegR1P",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "x": 273.1875,
      "y": 288.5,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "width": 1083.4791831970215,
      "height": 4750,
      "seed": 1666264850,
      "groupIds": [],
      "frameId": null,
      "roundness": null,
      "boundElements": [],
      "updated": 1722606356026,
      "link": null,
      "locked": false,
      "fontSize": 20,
      "fontFamily": 1,
      "text": "Data Replication:\nReplication is the process of keeping a copy of data across multiple \nnodes.\n\n\n\nWhy Data Replication?\n1. Keeping data geographically closer to the user.\n2. Allow the system to continue with read requests even if one of the\n   instances fails.\n3. to scale out the no of machines which can serve read queries.\n\n\n\nHow to keep data in sycn with data replication across multiple nodes?\n\n1. Master/slave replication (SQL)\n2. Multiple master replication. (SQL)\n3. Peer to peer replication. (NoSQL)\n\n\n\n\nMaster / Slave Replication\n\nOne Master - perform write operations from the server.\nAll other nodes (Slaves) - perform read operations from the server.\n\nOne master is selected for performing write operations. After the master\nhas performed write operations, then it will send the data changes to \nthe other nodes (slaves) of the system. The slaves will then write the\nlatest info received from the master to their servers.\n\n\nIt could be possibility that the server send a read request to the \nslave which has not been updated with the latest info from the master.\nThen, the slave will return stale info. But its okay, the slave will\nlater \"eventually catch up\".\n\n\nIf the master goes down, then the entire write operation is blocked,\nwhich makes the entire system to be locked. Only the read operations works.\ncheck node outrage section (down)\n\n\n\nIn a single master, when two users are to edit the same document, then\n\n1. User 2 actions will be persisted after user 1.\n2. User 2 actions will be temporarily will be aborted until user 1 is finished.\n\n\n\n\n\n\nMultiple master replication. (SQL)\nMultiple nodes can be selected as masters. \n\nThis can be setup in the multi-data centers. \n\nPros:\n1. Lower latency as the data replication to its slave and to other data\ncenters are hidden from the user.\n2. If one master fails from one data center, then other master of other\ndata center can take over.\n\n\nCons\nWrites conflicts - if one field from Master 1 (DC) is updated and the same field from \nMaster 2 (other DC) is updated at the same time then we have to figure out a way \nfor finding latest info.\n\n\n\nIn a multi-master, when two users tries to edit the same document:\n\n1. Then both users, sees the latest info in their local database replica. \n2. Conflicts becomes only apparent when data is async replicated across\nall replicas. \n\n\n\n\n\n1. Conflict avoidance - All writes going through same leader (wastage of having multi - masters).\n2. Converging towards a merge state by a predefined order - \n     a. Assigning unique id to writes - Fetch the latest write from all the replicas and update all\n        replicas with the new info.\n     b. Priority based on replica id - If replica 1 has most priority then the latest version of the value\n        is considered from replica 1.\n     c. Merging values - alphabetically or on timestamps etc.,.\n     d. Recording conflicts - if there a conflict is captured, then we can store this info and add \n        conflict resolution code on the application.  \n\n\n\n\n\n\n\n\n\nMasterless replication\nNo master.\nAll the nodes can perform read and write operations \n\n1. If there are N total nodes:\n2. W = Number of nodes required for verifying the write operation was successful. \n   (W<=N). \n   if W = N => \n       a) replication time is higher as it waits for all nodes to be written with \n          latest info.\n       b) And if one nodes goes down, then you can't process write.\n3. R = No of nodes required for verifying that the latest info is being fetched.\n   (R<=N)\n   if R = N =>\n         a) Every node will retrieve the latest info.\n         b) If one of the node fails, then you can't read the data.\n\n\n\nif W+R> N => then its guarantee that at least one of the read nodes \n              contains the latest write info.\n\nIt cqn still lead to  \n\nand write conflicts can be resolved from above steps.\n\n\n\nReplication: Sync Vs Async\nSync: \n    Master must wait for ack from all slaves nodes that they have persisted\n    with the latest info.\n    Good for consistency but terrible for availability.\n\nAsync:\n   Master sends the write operations to the slave and doesn't wait for the \n   confirmation from any of the slaves that they have written up the latest \n   info. \n   Good for availability but bad for consistency\n\n\n\nNodes Outrage\n\n1. If the slave node goes down:\n  Not a big problem.\n  Other slave nodes can take its place and continue performing read actions.\n  When that slave node come back online, then it can update with latest info\n  from the master\n\n\n2. if the master node goes down:\n   then the selection of new master is carried out:\n   The server will send write operations to the new master and other replicas has\n   now to accept write operations from the new master. \n     a) replicas having the most updated info can be selected as the new master.\n    \n  Issues with selecting a new master:\n      1. New master might not have all the latest write operations from the old master.\n      2. If old master comes back online, it might still think himself as the master.\n         Leading to the scenarios of two masters being present in one data center.\n         We can use fencing tokens (highest term number) to resolve conflicts of a split brain.\n         If the old leader has low term number, then it will automatically converted to\n         follower and new leader will continue working as the new leader.\n      3. How to setup threshold for determining a master is dead?\n\n         \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "Data Replication:\nReplication is the process of keeping a copy of data across multiple \nnodes.\n\n\n\nWhy Data Replication?\n1. Keeping data geographically closer to the user.\n2. Allow the system to continue with read requests even if one of the\n   instances fails.\n3. to scale out the no of machines which can serve read queries.\n\n\n\nHow to keep data in sycn with data replication across multiple nodes?\n\n1. Master/slave replication (SQL)\n2. Multiple master replication. (SQL)\n3. Peer to peer replication. (NoSQL)\n\n\n\n\nMaster / Slave Replication\n\nOne Master - perform write operations from the server.\nAll other nodes (Slaves) - perform read operations from the server.\n\nOne master is selected for performing write operations. After the master\nhas performed write operations, then it will send the data changes to \nthe other nodes (slaves) of the system. The slaves will then write the\nlatest info received from the master to their servers.\n\n\nIt could be possibility that the server send a read request to the \nslave which has not been updated with the latest info from the master.\nThen, the slave will return stale info. But its okay, the slave will\nlater \"eventually catch up\".\n\n\nIf the master goes down, then the entire write operation is blocked,\nwhich makes the entire system to be locked. Only the read operations works.\ncheck node outrage section (down)\n\n\n\nIn a single master, when two users are to edit the same document, then\n\n1. User 2 actions will be persisted after user 1.\n2. User 2 actions will be temporarily will be aborted until user 1 is finished.\n\n\n\n\n\n\nMultiple master replication. (SQL)\nMultiple nodes can be selected as masters. \n\nThis can be setup in the multi-data centers. \n\nPros:\n1. Lower latency as the data replication to its slave and to other data\ncenters are hidden from the user.\n2. If one master fails from one data center, then other master of other\ndata center can take over.\n\n\nCons\nWrites conflicts - if one field from Master 1 (DC) is updated and the same field from \nMaster 2 (other DC) is updated at the same time then we have to figure out a way \nfor finding latest info.\n\n\n\nIn a multi-master, when two users tries to edit the same document:\n\n1. Then both users, sees the latest info in their local database replica. \n2. Conflicts becomes only apparent when data is async replicated across\nall replicas. \n\n\n\n\n\n1. Conflict avoidance - All writes going through same leader (wastage of having multi - masters).\n2. Converging towards a merge state by a predefined order - \n     a. Assigning unique id to writes - Fetch the latest write from all the replicas and update all\n        replicas with the new info.\n     b. Priority based on replica id - If replica 1 has most priority then the latest version of the value\n        is considered from replica 1.\n     c. Merging values - alphabetically or on timestamps etc.,.\n     d. Recording conflicts - if there a conflict is captured, then we can store this info and add \n        conflict resolution code on the application.  \n\n\n\n\n\n\n\n\n\nMasterless replication\nNo master.\nAll the nodes can perform read and write operations \n\n1. If there are N total nodes:\n2. W = Number of nodes required for verifying the write operation was successful. \n   (W<=N). \n   if W = N => \n       a) replication time is higher as it waits for all nodes to be written with \n          latest info.\n       b) And if one nodes goes down, then you can't process write.\n3. R = No of nodes required for verifying that the latest info is being fetched.\n   (R<=N)\n   if R = N =>\n         a) Every node will retrieve the latest info.\n         b) If one of the node fails, then you can't read the data.\n\n\n\nif W+R> N => then its guarantee that at least one of the read nodes \n              contains the latest write info.\n\nIt cqn still lead to  \n\nand write conflicts can be resolved from above steps.\n\n\n\nReplication: Sync Vs Async\nSync: \n    Master must wait for ack from all slaves nodes that they have persisted\n    with the latest info.\n    Good for consistency but terrible for availability.\n\nAsync:\n   Master sends the write operations to the slave and doesn't wait for the \n   confirmation from any of the slaves that they have written up the latest \n   info. \n   Good for availability but bad for consistency\n\n\n\nNodes Outrage\n\n1. If the slave node goes down:\n  Not a big problem.\n  Other slave nodes can take its place and continue performing read actions.\n  When that slave node come back online, then it can update with latest info\n  from the master\n\n\n2. if the master node goes down:\n   then the selection of new master is carried out:\n   The server will send write operations to the new master and other replicas has\n   now to accept write operations from the new master. \n     a) replicas having the most updated info can be selected as the new master.\n    \n  Issues with selecting a new master:\n      1. New master might not have all the latest write operations from the old master.\n      2. If old master comes back online, it might still think himself as the master.\n         Leading to the scenarios of two masters being present in one data center.\n         We can use fencing tokens (highest term number) to resolve conflicts of a split brain.\n         If the old leader has low term number, then it will automatically converted to\n         follower and new leader will continue working as the new leader.\n      3. How to setup threshold for determining a master is dead?\n\n         \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
      "autoResize": true,
      "lineHeight": 1.25
    },
    {
      "type": "text",
      "version": 108,
      "versionNonce": 689565924,
      "index": "c09v",
      "isDeleted": false,
      "id": "2xfaZBqFJZrjum1YEtGzS",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "x": 282.2356066852808,
      "y": 1262.5703125,
      "strokeColor": "#e03131",
      "backgroundColor": "transparent",
      "width": 46.1199731528759,
      "height": 25,
      "seed": 375282719,
      "groupIds": [],
      "frameId": null,
      "roundness": null,
      "boundElements": [],
      "updated": 1722605776845,
      "link": null,
      "locked": false,
      "fontSize": 20,
      "fontFamily": 5,
      "text": "Cons",
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "Cons",
      "autoResize": true,
      "lineHeight": 1.25
    },
    {
      "type": "text",
      "version": 236,
      "versionNonce": 40173404,
      "index": "c09w",
      "isDeleted": false,
      "id": "UEnZeqCtgLiwH5YDQ5EkZ",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "x": 279.3645129352808,
      "y": 1414.78515625,
      "strokeColor": "#e03131",
      "backgroundColor": "transparent",
      "width": 97.919921875,
      "height": 25,
      "seed": 200432529,
      "groupIds": [],
      "frameId": null,
      "roundness": null,
      "boundElements": [],
      "updated": 1722605776845,
      "link": null,
      "locked": false,
      "fontSize": 20,
      "fontFamily": 5,
      "text": "Conflict &",
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "Conflict &",
      "autoResize": true,
      "lineHeight": 1.25
    },
    {
      "type": "text",
      "version": 495,
      "versionNonce": 32650340,
      "index": "c09x",
      "isDeleted": false,
      "id": "3CXtb0QdawjeYiXEmL5gE",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "x": 279.10672707557677,
      "y": 2374.66015625,
      "strokeColor": "#2f9e44",
      "backgroundColor": "transparent",
      "width": 197.35429487228396,
      "height": 26.554687500000007,
      "seed": 1445430783,
      "groupIds": [],
      "frameId": null,
      "roundness": null,
      "boundElements": [],
      "updated": 1722605776845,
      "link": null,
      "locked": false,
      "fontSize": 21.243750000000002,
      "fontFamily": 5,
      "text": "Conflict Resolution",
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "Conflict Resolution",
      "autoResize": true,
      "lineHeight": 1.25
    },
    {
      "type": "text",
      "version": 321,
      "versionNonce": 1959048156,
      "index": "c09y",
      "isDeleted": false,
      "id": "cGzfdRRoXLCV_mgmuwQaO",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "x": 277.6484375,
      "y": 2127.5390625,
      "strokeColor": "#e03131",
      "backgroundColor": "transparent",
      "width": 75.5599365234375,
      "height": 25,
      "seed": 338157599,
      "groupIds": [],
      "frameId": null,
      "roundness": null,
      "boundElements": [],
      "updated": 1722605776845,
      "link": null,
      "locked": false,
      "fontSize": 20,
      "fontFamily": 5,
      "text": "Conflict",
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "Conflict",
      "autoResize": true,
      "lineHeight": 1.25
    },
    {
      "type": "text",
      "version": 152,
      "versionNonce": 771098596,
      "index": "c09z",
      "isDeleted": false,
      "id": "YvQdwpcBDzDRATLl1luli",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "x": 386.62734389305115,
      "y": 1415.8359375,
      "strokeColor": "#2f9e44",
      "backgroundColor": "transparent",
      "width": 102.8599362373352,
      "height": 25,
      "seed": 1768131583,
      "groupIds": [],
      "frameId": null,
      "roundness": null,
      "boundElements": [],
      "updated": 1722605776845,
      "link": null,
      "locked": false,
      "fontSize": 20,
      "fontFamily": 5,
      "text": "Resolution",
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "Resolution",
      "autoResize": true,
      "lineHeight": 1.25
    },
    {
      "type": "text",
      "version": 553,
      "versionNonce": 1513740380,
      "index": "c0A0",
      "isDeleted": false,
      "id": "jU2SD-VUQCOV27hPbxWLR",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "x": 483.1216296780249,
      "y": 3412.15625,
      "strokeColor": "#e03131",
      "backgroundColor": "transparent",
      "width": 186.83230216738775,
      "height": 25.96512838891363,
      "seed": 345777201,
      "groupIds": [],
      "frameId": null,
      "roundness": null,
      "boundElements": [],
      "updated": 1722605776845,
      "link": null,
      "locked": false,
      "fontSize": 20.772102711130906,
      "fontFamily": 5,
      "text": "write conflicts",
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "write conflicts",
      "autoResize": false,
      "lineHeight": 1.25
    }
  ],
  "appState": {
    "gridSize": null,
    "viewBackgroundColor": "#ffffff"
  },
  "files": {}
}
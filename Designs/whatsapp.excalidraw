{
  "type": "excalidraw",
  "version": 2,
  "source": "https://excalidraw.com",
  "elements": [
    {
      "type": "text",
      "version": 1483,
      "versionNonce": 459963894,
      "index": "b2M",
      "isDeleted": false,
      "id": "H-9GhqBfpRi0cRLpobN5C",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "x": 660.671875,
      "y": 9.99609375,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "width": 1097.9591064453125,
      "height": 2650,
      "seed": 997175594,
      "groupIds": [],
      "frameId": null,
      "roundness": null,
      "boundElements": [],
      "updated": 1721715116443,
      "link": null,
      "locked": false,
      "fontSize": 20,
      "fontFamily": 1,
      "text": "Whatsapp\n\n\nFunctional Requirements\n1. User should be able to send/receive msges.\n2. User should be able to send/receive images.\n3. Users should be able to start group chat with multiple\nparticipants (limit 100).\n4. Users should be able to receive msges when they are not \nonline (upto 30 days)\n\n\n\nNon-functional requirements\n1. Msges delivered to users with low latency of <500ms.\n2. The msgs should be deliverable.\n3. The system should be resilient in terms of individual components \nfailure.\n4. It should be scalable upto 100M+ users.\n5. Msges should not be stored on servers more than necessary.\n\n\n\nEntities\nmsgs\nusers\ngroups\nclients (user can have more than one device for chating)\n\n\n\nAPI \n\n\nOur external-facing API for this system is likely a bi-directional socket connection. \nFor this interview, we'll just use websockets although a simple TLS connection would do. \nThe idea will be that users will open the app and connect to the server, opening this socket.\n\nSince our clients can go offline, we'll need to be able to \"sync\" state between the client and server. \nFor convenience, let's just assume the server will buffer events sent while the client is offline and, \nwhen the client connects, it receives all unsent messages. \nWe'll also assume TCP-style guarantees (delivery, order) here.\n\ncreate group\nPOST /group\nbody : {\n   participants:List<userIds>,\n   name:\"\",\n   description:\"\"\n}\nResponse ok\n\n\nupdate group\nPUT /group\nbody : {\n   \"group_id\":\"encrypted\"\n   new_participants:List<userIds>,\n   name:\"\",\n   description:\"\"\n}\nResponse ok\n\n\n\ncreate msg\nPOST /message \nBody : {\n  \"content\":\"...\",\n  \"group_id\":\"encrypted\",\n  \"sender_participant_id\":\"user_id\"\n}\n\n\n\ncreate attachment\nPOST /attachement\nbody: {\n   hash:\"jcjdhjdjc\"\n}\n\n\n\n\n\nreceive message\nGET /message \nResponse:\n{\n   \"sender_user_id\",\n   \"receiver_participants:[],\n   \"message\",\n   attachment:\"\"\n}\n\n\n\n\nEach of these messages will have a parallel message that is sent to other clients. \nEach of these will be formally acknowledged so the server can keep track of delivery.\n\nThe message receipt acknowledgement is a bit non-obvious but crucial to making sure we don't lose messages. \nOnce the client has \"ack'd\" a message, the server can assume it's been received \nand the message can be discarded (for that user).\n\n",
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "Whatsapp\n\n\nFunctional Requirements\n1. User should be able to send/receive msges.\n2. User should be able to send/receive images.\n3. Users should be able to start group chat with multiple\nparticipants (limit 100).\n4. Users should be able to receive msges when they are not \nonline (upto 30 days)\n\n\n\nNon-functional requirements\n1. Msges delivered to users with low latency of <500ms.\n2. The msgs should be deliverable.\n3. The system should be resilient in terms of individual components \nfailure.\n4. It should be scalable upto 100M+ users.\n5. Msges should not be stored on servers more than necessary.\n\n\n\nEntities\nmsgs\nusers\ngroups\nclients (user can have more than one device for chating)\n\n\n\nAPI \n\n\nOur external-facing API for this system is likely a bi-directional socket connection. \nFor this interview, we'll just use websockets although a simple TLS connection would do. \nThe idea will be that users will open the app and connect to the server, opening this socket.\n\nSince our clients can go offline, we'll need to be able to \"sync\" state between the client and server. \nFor convenience, let's just assume the server will buffer events sent while the client is offline and, \nwhen the client connects, it receives all unsent messages. \nWe'll also assume TCP-style guarantees (delivery, order) here.\n\ncreate group\nPOST /group\nbody : {\n   participants:List<userIds>,\n   name:\"\",\n   description:\"\"\n}\nResponse ok\n\n\nupdate group\nPUT /group\nbody : {\n   \"group_id\":\"encrypted\"\n   new_participants:List<userIds>,\n   name:\"\",\n   description:\"\"\n}\nResponse ok\n\n\n\ncreate msg\nPOST /message \nBody : {\n  \"content\":\"...\",\n  \"group_id\":\"encrypted\",\n  \"sender_participant_id\":\"user_id\"\n}\n\n\n\ncreate attachment\nPOST /attachement\nbody: {\n   hash:\"jcjdhjdjc\"\n}\n\n\n\n\n\nreceive message\nGET /message \nResponse:\n{\n   \"sender_user_id\",\n   \"receiver_participants:[],\n   \"message\",\n   attachment:\"\"\n}\n\n\n\n\nEach of these messages will have a parallel message that is sent to other clients. \nEach of these will be formally acknowledged so the server can keep track of delivery.\n\nThe message receipt acknowledgement is a bit non-obvious but crucial to making sure we don't lose messages. \nOnce the client has \"ack'd\" a message, the server can assume it's been received \nand the message can be discarded (for that user).\n\n",
      "autoResize": true,
      "lineHeight": 1.25
    }
  ],
  "appState": {
    "gridSize": null,
    "viewBackgroundColor": "#ffffff"
  },
  "files": {}
}